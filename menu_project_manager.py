# -*- coding: utf8 -*-
#	Menu Project Manager plugin
#
#	spetial thanks to Micah:
#	http://www.micahcarrick.com/writing-plugins-for-gedit-3-in-python.html
#
#	Copyright (C) 2013 Francisco Franchetti <nixahn@gmail.com>
#	Copyright (C) 2006 Alin Avasilcutei (Gyll) <avasilcuteia@gmail.com>
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330,
#	Boston, MA 02111-1307, USA.

# bugs/todo:
#	1_ this bug is hard to reproduce, seems gone: (gedit:30664): GLib-GObject-WARNING **: /build/buildd/glib2.0-2.38.1/./gobject/gsignal.c:2593: instance '0x912d218' has no handler with id '6760'
#	2_ probably better to implement the history with xml too instead of with a simple file handler (open())
#	3_ should migrate to Gio.SimpleAction instead of the deprecated GtkAction
#	4_ there are issues with the sftp locations; the addision of files through the "choose_dialog" has a different way of storing the path than when one uses the "add current file menu item" (which depends on get_uri_for_display); in general there is a need to compare files more abstractly (instead of just the string that represents them); we should aim at allowing for any uri (including web url ones) in the project list and we should write a somewhat thorough function that checks if two strings are ultimately pointing at the same uri, indepently of links, notation, etc. The main problem now is that the powerful functions os.path to check existence and compare the strings are restricted to local paths; the gfile opener used depends on uri, so we have to prepend the "file://" to the outputs generated by _get_uri_for_display to make them compatible. the chooser dialog tends to generate valid uris directly, although they don't coincide with the ones generated by get_uri_for_display when we are dealing with a non-local uri; something similar to this would help with the normalization (not the same as checking for the inode as os.path.samefile does though! ); it also misses the link resolution
# def fix_URL(urlstring):
#    parts = list(urlparse.urlparse(urlstring))
#    parts[2] = os.path.normpath(parts[2].replace('/', os.sep)).replace(os.sep, '/')
#    return urlparse.urlunparse(parts)
#	5_ rorder the files in the project according to how they are ordered in the tabs.
#	6_ open a new window when a new project is opened
#	7_ close a unique untouched "untilted_document" when a project is opened

from gi.repository import GObject, Gedit, Gtk ,Gio
from os.path import os
from sys import platform
from subprocess import call
from io import IOBase
# from urllib import request
from xml.dom import minidom

ui_str="""<ui>
<menubar name="MenuBar">
	<menu name="ProjectMenu" action="ProjectMenuAction">
		<placeholder name="ProjectOps_1">
			<menuitem name="NewProject" action="NewProjectAction"/>
		</placeholder>
		<placeholder name="ProjectOps_2">
			<menuitem name="OpenProject" action="OpenProjectAction"/>
			<menuitem name="OpenLastProjectMenu" action="OpenLastProjectMenuAction"/>
			<menuitem name="CloseProject" action="CloseProjectAction"/>
			<separator />
			<menuitem name="OpenFileAsProject" action="OpenFileAsProjectAction"/>
			<separator />
			<menuitem name="ViewProjectFiles" action="ViewProjectFilesAction"/>
			<menuitem name="ReopenAllFiles" action="ReopenAllFilesAction"/>
			<separator />
		</placeholder>
		<placeholder name="ProjectOps_3">
			<menuitem name="AddProjectFile" action="AddProjectFileAction"/>
			<menuitem name="AddCurrentFile" action="AddCurrentFileAction"/>
			<menuitem name="DelProjectFile" action="DelProjectFileAction"/>
			<separator />
		</placeholder>
		<placeholder name="ProjectOps_4">
			<menuitem name="OpenCurrentFileFolder" action="OpenCurrentFileFolderAction"/>
			<menuitem name="OpenProjectFolder" action="OpenProjectFolderAction"/>
			<separator />
		</placeholder>
		<placeholder name="ProjectOps_5">
		</placeholder>
	</menu>
</menubar>
<toolbar name="ToolBar">
	<separator />
	<toolitem name="OpenLastProjectButton" action="OpenLastProjectButtonAction"/>
</toolbar> 
</ui>
"""
class ProjectData:

	def __init__( self ):
		self.filename = ""
		self._files = list()
		self.active = False

	def add_file( self, file_uri ):
		if file_uri in self._files:
			return False

		print ("Adding file to project ... " + file_uri)
		self._files.append( file_uri )
		return True

	def del_file( self, file_uri ):
		if file_uri in self._files:
			self._files.remove( file_uri )
			return True
		return False

	def get_files( self ):
		return self._files

	def clear( self ):
		self.name = ""
		self.filename = ""
		self._files = list()
		self.active = False

class MenuProjectPluginInstance:
	CHOOSER_OPEN = 10
	CHOOSER_SAVE = 11
	CHOOSER_CANCEL = 12
	CHOOSER_NEW = 13
	CHOOSER_OK = 14
	OPEN_PROJECT = 20
	SAVE_PROJECT = 21
	NEW_PROJECT = 22
	OPEN_FILES = 23
	SAVE_FILE = 24
	SAVE_AND_CLOSE_FILE = 25
	WITH_LOG = True
	MAX_HISTORY_FILE_NO = 15
	STATE_PROJECT_NO_FILES_NO	= 0
	STATE_PROJECT_YES_FILES_NO	= 1
	STATE_PROJECT_NO_FILES_YES	= 2
	STATE_PROJECT_YES_FILES_YES = 3
	
	CAN_ADD_FILE = 1
	CAN_REM_FILE = 2
	
	GEDIT_PLUGIN_FOLDER = "/.local/share/gedit/plugins"

	def __init__( self, plugin, window ):
		self._window = window
		self._documents = list()
		self._plugin = plugin
		self._project = ProjectData()
		self._history_file = os.path.expanduser( '~' ) + self.GEDIT_PLUGIN_FOLDER+"/menu_project_manager_history"
		self._history = list()
		self._action_group = Gtk.ActionGroup( "MenuProjectPluginActions" )
		self._history_action_group = Gtk.ActionGroup( "MenuProjectPluginHistoryActions" )
		self._state = self.STATE_PROJECT_NO_FILES_NO
		self._add_remove_state = None
		self._message = list()
		
		self._init_history()
		self._insert_menu()
		self._create_choosers()

	def deactivate( self ):
		self._remove_menu()
		self._save_history()
		self._action_group = None
		self._project = None
		self._plugin = None
		self._window = None

		self._open_file_chooser = None
		self._save_file_chooser = None

	def update_ui( self ):
		manager = self._window.get_ui_manager()
		# REMOVE OLD HISTORY
		manager.remove_ui( self._ui_id_history )
		manager.remove_action_group(self._history_action_group)
		self._history_action_group = Gtk.ActionGroup( "MenuProjectPluginHistoryActions" )
		manager.ensure_update()
		# INSERT NEW HISTORY
		if len(self._history) != 0:
			for item in self._history:
				if item != "":
					self._insert_history_menu_item( manager, item, self._history.index( item ) )
		manager.insert_action_group( self._history_action_group, 1 )
		manager.ensure_update()
		# SET BUTTONS SENSITIVITY
		self._add_remove_state = None
		if (self._window.get_active_document() and self._window.get_active_document().get_uri_for_display() != None):
			if (self._project.active):
				self._state = self.STATE_PROJECT_YES_FILES_YES
				if (self._window.get_active_document() in self._documents):
					self._add_remove_state = self.CAN_REM_FILE
				else:
					self._add_remove_state = self.CAN_ADD_FILE
			else:
				self._state = self.STATE_PROJECT_NO_FILES_YES
		else:
			if (self._project.active):
				self._state = self.STATE_PROJECT_YES_FILES_NO
			else:
				self._state = self.STATE_PROJECT_NO_FILES_NO
		self._set_menu_state( manager )
		#print( self._state )
		return

	def _set_menu_state( self, manager ):
		#print( "Set Menu State" )
		manager.get_action("/ToolBar/OpenLastProjectButton").set_sensitive( len(self._history) != 0 and not self._project.active)

		manager.get_action("/MenuBar/ProjectMenu/ProjectOps_1/NewProject").set_sensitive( not self._project.active )
		manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/OpenProject").set_sensitive( not self._project.active )

		manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/OpenFileAsProject").set_sensitive( False )
		if (not self._project.active):
			if self._window.get_active_document() and self._window.get_active_document().get_uri_for_display():
				if self._has_gedit_project_extension(self._window.get_active_document().get_uri_for_display()):
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/OpenFileAsProject").set_sensitive( True )

		manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/OpenLastProjectMenu").set_sensitive( len(self._history) != 0 and not self._project.active)

		if (self._state == self.STATE_PROJECT_NO_FILES_NO):
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/CloseProject").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ViewProjectFiles").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddProjectFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ReopenAllFiles").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenProjectFolder").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenCurrentFileFolder").set_sensitive(False)
		elif (self._state == self.STATE_PROJECT_YES_FILES_NO):
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/CloseProject").set_sensitive(True)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ViewProjectFiles").set_sensitive(True)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddProjectFile").set_sensitive(True)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ReopenAllFiles").set_sensitive(True)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenProjectFolder").set_sensitive(True)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenCurrentFileFolder").set_sensitive(False)
		elif (self._state == self.STATE_PROJECT_NO_FILES_YES):
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/CloseProject").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ViewProjectFiles").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddProjectFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ReopenAllFiles").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenProjectFolder").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenCurrentFileFolder").set_sensitive(True)
		elif (self._state == self.STATE_PROJECT_YES_FILES_YES):
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/CloseProject").set_sensitive(True)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ViewProjectFiles").set_sensitive(True)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddProjectFile").set_sensitive(True)
				if (self._add_remove_state == self.CAN_ADD_FILE):
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(True)
				else:
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ReopenAllFiles").set_sensitive(True)
				if (self._add_remove_state == self.CAN_REM_FILE):
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(True)
				else:
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(False)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenProjectFolder").set_sensitive(True)
				manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenCurrentFileFolder").set_sensitive(True)

	def _init_history( self ):
		if os.path.exists( self._history_file ) == True:
			hist_fp = open( self._history_file, "r" )
			try:
				for line in hist_fp:
					self._history.insert( len( self._history ) , line.rstrip("\n"))
			finally:
				hist_fp.close()
		else:
			hist_fp = open( self._history_file, "w" )
			hist_fp.close()

	def _add_to_history( self, filename ):
		if filename != "":
			for item in self._history:
				#if item == filename:
				if os.path.samefile(item,filename): #avoids symlink duplicates
					self._history.remove( item )
			if os.path.exists(filename):
				if len( self._history ) == self.MAX_HISTORY_FILE_NO:
					self._history.pop( len( self._history )-1 )
				self._history.insert( 0, filename )
			self._save_history()
			self.update_ui()


	def _save_history( self ):
		# print( "Saving the history ... " )
		hist_fp = open( self._history_file, "w" )
		for line in self._history:
			hist_fp.write( line + "\n" )
		hist_fp.close()

	def _insert_history_menu_item( self, manager, filename, position ):
		file_name, file_ext = os.path.splitext( os.path.basename( filename ) )
		action_label = str( position + 1 ) + ". " + file_name
		manager.add_ui(
			merge_id = self._ui_id_history,
			path = "/MenuBar/ProjectMenu/ProjectOps_5",
			name = filename,
			action = filename,
			type = Gtk.UIManagerItemType.AUTO,
			top = False
		)
		history_action = Gtk.Action(
			name = filename,
			label = action_label,
			tooltip=filename,
			stock_id=None
		)
		history_action.connect("activate", lambda a: self.on_history_action(filename) )
		history_action.set_sensitive( not self._project.active )
		history_action.set_visible(True)
		self._history_action_group.add_action( history_action )

	def _insert_menu( self ):
		"create and add the Project menu to the menubar"

		#TOOLBAR
		open_last_project_button_action = Gtk.Action(
			name="OpenLastProjectButtonAction",
			label="Last Project",
			tooltip="Reopen the last project",
			stock_id=Gtk.STOCK_GO_BACK
		)
		open_last_project_button_action.connect( "activate", lambda a: self.on_open_last_project_action() )
		self._action_group.add_action( open_last_project_button_action )

		# PROJECT MENU
		project_menu_action = Gtk.Action(
			name="ProjectMenuAction",
			label="Project",
			tooltip="Project menu",
			stock_id=None
		)
		project_menu_action.connect( "activate", lambda a: self.update_ui() )
		self._action_group.add_action( project_menu_action )

		## First Placeholder ##
		new_project_action = Gtk.Action(	name="NewProjectAction",
											label="New Project...\t",
											tooltip="Create a new project",
											stock_id=Gtk.STOCK_NEW )
		new_project_action.connect( "activate", lambda a: self.on_new_project_action() )
		self._action_group.add_action( new_project_action )

		open_project_action = Gtk.Action(
			name="OpenProjectAction",
			label="Open Project...\t",
			tooltip="Open a project file",
			stock_id=Gtk.STOCK_OPEN
		)
		open_project_action.connect( "activate", lambda a: self.on_open_project_action() )
		self._action_group.add_action( open_project_action )

		open_last_project_menu_action = Gtk.Action(
			name="OpenLastProjectMenuAction",
			label="Open Last Project",
			tooltip="Reopen the last project",
			stock_id=Gtk.STOCK_GO_BACK
		)
		open_last_project_menu_action.connect( "activate", lambda a: self.on_open_last_project_action() )
		self._action_group.add_action( open_last_project_menu_action )

		close_project_action = Gtk.Action(
			name="CloseProjectAction",
			label="Close Project\t",
			tooltip="Closes the current project",
			stock_id=Gtk.STOCK_QUIT
		)
		close_project_action.connect( "activate", lambda a: self.on_close_project_action() )
		self._action_group.add_action( close_project_action )

		## Second Placeholder ##
		open_file_as_project_action = Gtk.Action(
			name="OpenFileAsProjectAction",
			label="Open Current File as Project\t",
			tooltip="Open the project associated with the current '.gedit-project' file",
			stock_id=None
		)
		open_file_as_project_action.connect( "activate", lambda a: self.on_open_file_as_project_action() )
		self._action_group.add_action( open_file_as_project_action )

		## Third Placeholder ##
		view_project_files_action = Gtk.Action(
			name="ViewProjectFilesAction",
			label="View Project File List\t",
			tooltip="Displays a list with the files in the project.",
			stock_id=Gtk.STOCK_INFO
		)
		view_project_files_action.connect( "activate", lambda a: self.on_view_project_files_action() )
		self._action_group.add_action_with_accel( view_project_files_action, "<Ctrl>3" )
		open_all_files_action = Gtk.Action(
			name="ReopenAllFilesAction",
			label="Open All Files In Project\t",
			tooltip="Opens all the files contained in the current project",
			stock_id=Gtk.STOCK_REFRESH
		)
		open_all_files_action.connect( "activate", lambda a: self.on_open_all_files_action() )
		self._action_group.add_action_with_accel( open_all_files_action, "<Ctrl>2" )

		## Fourth Placeholder ##
		add_file_action = Gtk.Action(
			name="AddProjectFileAction",
			label="Add Files ...\t",
			tooltip="Adds an existing file to the opened project",
			stock_id=Gtk.STOCK_DND_MULTIPLE
		)
		add_file_action.connect( "activate", lambda a: self.on_add_file_action() )
		self._action_group.add_action( add_file_action )

		add_current_file_action = Gtk.Action(
			name="AddCurrentFileAction",
			label="Add Current File\t",
			tooltip="Adds the current file to the opened project",
			stock_id=Gtk.STOCK_DND
		)
		add_current_file_action.connect( "activate", lambda a: self.on_add_current_file_action() )
		self._action_group.add_action_with_accel( add_current_file_action, "<Ctrl>1" )
		del_file_action = Gtk.Action(
			name="DelProjectFileAction",
			label="Remove Current File\t",
			tooltip="Removes the active file from the project",
			stock_id=Gtk.STOCK_DELETE
		)
		del_file_action.connect( "activate", lambda a: self.on_del_file_action() )
		self._action_group.add_action_with_accel( del_file_action, "<Ctrl>0" )
		
		## Fifth Placeholder ##
		open_project_folder_action = Gtk.Action(
			name="OpenProjectFolderAction",
			label="Open Project File Folder...\t",
			tooltip="Open the folder containing the project file.",
			stock_id=None
		)
		open_project_folder_action.connect( "activate", lambda a: self.on_open_project_folder_action() )
		self._action_group.add_action( open_project_folder_action )

		open_file_folder_action = Gtk.Action(
			name="OpenCurrentFileFolderAction",
			label="Open Current File Folder...\t",
			tooltip="Open the current project's folder.",
			stock_id=None
		)
		open_file_folder_action.connect( "activate", lambda a: self.on_open_files_folder_action() )
		self._action_group.add_action( open_file_folder_action )

		manager = self._window.get_ui_manager()
		manager.insert_action_group( self._action_group, 0 )
		manager.insert_action_group( self._history_action_group, 1 )
		
		self._ui_id_history = manager.new_merge_id()
		self._ui_id_main = manager.add_ui_from_string( ui_str )
		manager.ensure_update()

	def _remove_menu( self ):
		"removes the project menu items from the menu"
		manager = self._window.get_ui_manager()
		manager.remove_ui( self._ui_id_history )
		manager.remove_ui( self._ui_id_main )
		manager.remove_action_group( self._action_group )
		manager.ensure_update()

	def _create_choosers( self ):
		"Creates open/save file choosers for opening and saving projects"
		self.project_file_filter = Gtk.FileFilter()
		self.project_file_filter.add_pattern("*.gedit-project")
		self.all_files_filter = Gtk.FileFilter()
		self.all_files_filter.add_pattern("*")

		self._open_file_chooser = Gtk.FileChooserDialog(
			"Open Project File",
			self._window,
			Gtk.FileChooserAction.OPEN
		)
		self._open_file_chooser.set_select_multiple( False )
		self._open_file_chooser.add_buttons(
			Gtk.STOCK_OPEN, self.CHOOSER_OPEN,
			Gtk.STOCK_CANCEL, self.CHOOSER_CANCEL
		)
		self._save_file_chooser = Gtk.FileChooserDialog(
			"Save Project File",
			self._window,
			Gtk.FileChooserAction.SAVE
		)
		self._save_file_chooser.set_select_multiple( False )
		self._save_file_chooser.add_buttons(
			Gtk.STOCK_SAVE, self.CHOOSER_SAVE,
			Gtk.STOCK_CANCEL, self.CHOOSER_CANCEL
		)
		self._open_fa_id = -1
		self._open_resp_id = -1
		self._save_fa_id = -1
		self._save_resp_id = -1

	#### MENU ITEM ACTIONS ####

	## First Placeholder ##
	def on_new_project_action( self ):
		"Displays the new project dialog box"
		self._show_chooser( self.NEW_PROJECT )

	## Second Placeholder ##
	def on_open_project_action( self ):
		"Activated when the 'open project' menu item is selected"
		self._show_chooser( self.OPEN_PROJECT )

	def on_close_project_action( self ):
		"Close the active project"
		filename = os.path.basename( self._project.filename )
		self._save_project( self._project.filename )
#GYLL	self._show_alert( "Project closed: " + self._project.filename, self.WITH_LOG )
		self._close_project()
		if self._message: self._show_alert( "Project closed: " + filename, self.WITH_LOG )

	def on_view_project_files_action( self ):
		file_list = list()
		xml = minidom.parse( self._project.filename )
		for file_uri in xml.getElementsByTagName( 'file' ):
			file_list.append( file_uri.childNodes[0].data )
#GYLL	message = "Current project: " + os.path.basename(self._project.filename) + "\nFiles in the project:"
		message = "Current project:\n" + self._project.filename + "\n\nFiles in the project:"
		while file_list:
			message = message + "\n - " + file_list.pop()
		self._show_alert( message , False, Gtk.DialogFlags.DESTROY_WITH_PARENT )

	def on_open_project_folder_action( self ):
		"Open the current project folder."
		if os.path.dirname(self._project.filename):
			f=os.path.dirname(self._project.filename)
			if platform == 'linux':
				call(["xdg-open",f])
			else:
				os.startfile(f)
		else:
			self._show_alert( "Can not open the project folder.\nReason: Path not found." )

	def on_open_files_folder_action( self ):
		"Open the current file folder."
		if (self._window.get_active_document()):
			if(self._window.get_active_document().get_uri_for_display()):
				current_file = self._window.get_active_document().get_uri_for_display()
				if os.path.dirname(current_file):
					f=os.path.dirname(current_file)
					if platform == 'linux': # http://stackoverflow.com/questions/1679798/how-to-open-a-file-with-the-standard-application
						call(["xdg-open",f])
					else:
						os.startfile(f)
				else:
					self._show_alert( "Can not open the project folder.\nReason: Path not found." )
		else:
			self._show_alert( "There is no open file or the current file is untitled." )

	## Third Placeholder ##
	def on_add_file_action( self ):
		"Adds an existing file to the active project."
		self._show_chooser( self.OPEN_FILES )

	def on_add_current_file_action( self ):
		"Adds the active file to the active project."
		if self._window.get_active_document():
			doc = self._window.get_active_document()
			# print( "Adding file to project ... " + doc.get_uri_for_display() )
			if doc in self._documents:
				self._show_alert(
					"The current file is ALREADY IN the project: " +
					doc.get_uri_for_display()
				)

			else:
				self._documents.append(doc)
				self._show_alert(
					"The current file has been ADDED to the project: " +
					doc.get_uri_for_display()
				)
			file_uri= doc.get_uri_for_display()	# modifiy uri_for display here to make the value a true uri with file:// preceeding; that prepending is necessary tomake the value readable later for the gfile new_for_uri method; using this instead of new_for_path allows to have files in the project with more flexible locations (sftp) and such
			if os.path.isabs(file_uri):
				file_uri= "file://" + file_uri # There should be some library that I couldn't find doint this kind of path->uri conversion;
			self._project.add_file( file_uri )
			self._save_project( self._project.filename )
	
	def on_open_all_files_action( self ):
		self._open_project( self._project.filename )
		self._save_project( self._project.filename )
		if self._message: self._show_alert( "Project reopened: '" + os.path.basename( self._project.filename ) + "'", self.WITH_LOG )
	
	def on_del_file_action( self ):
		"Removes the active file from the active project."
		if self._window.get_active_document():
			doc = self._window.get_active_document()
			if doc in self._documents:
				# print( "Removing file from project: " + doc.get_uri_for_display() )
				self._project.del_file( doc.get_uri_for_display() )
				#self._window.close_tab( Gedit.Tab.get_from_document( doc ) )
				self._save_project( self._project.filename )
				self._documents.remove( doc )
				self._show_alert(
					"The current file has been REMOVED from the project: " +
					doc.get_uri_for_display()
				)

			else:
				self._show_alert(
					"The current file doesn't belong to project: " +
					doc.get_uri_for_display()
				)

	## CHOOSER ACTIONS ##
	def _show_chooser( self, chooser_type ):
		"A unified interface to show both open/save file choosers"
		if self._open_fa_id > -1: self._open_file_chooser.disconnect( self._open_fa_id )
		if self._open_resp_id > -1: self._open_file_chooser.disconnect( self._open_resp_id )
		if self._save_fa_id > -1: self._save_file_chooser.disconnect( self._save_fa_id )
		if self._save_resp_id > -1: self._save_file_chooser.disconnect( self._save_resp_id )

		if chooser_type == self.OPEN_PROJECT:
			self._open_file_chooser.set_title( "Open Project File" )
			self._open_file_chooser.set_filter(self.project_file_filter)
			self._open_file_chooser.set_select_multiple( False )
			self._open_fa_id = self._open_file_chooser.connect( "file-activated", 
			self.on_open_project,
			self.CHOOSER_OPEN )
			self._open_resp_id = self._open_file_chooser.connect( "response", self.on_open_project )
			self._open_file_chooser.show()

		elif chooser_type == self.OPEN_FILES:
			self._open_file_chooser.set_title( "Add File to Project" )
			self._open_file_chooser.set_filter(self.all_files_filter)
			self._open_file_chooser.set_select_multiple( True )
			self._open_fa_id = self._open_file_chooser.connect( "file-activated",
			self.on_open_files,
			self.CHOOSER_OPEN )
			self._open_resp_id = self._open_file_chooser.connect( "response", self.on_open_files )
			self._open_file_chooser.show()

		elif chooser_type == self.NEW_PROJECT:
			self._save_file_chooser.set_title( "Save New Project File As ..." )
			self._save_file_chooser.set_filter(self.project_file_filter)
			filename="new_project"
			if self._window.get_active_document():
				filename=self._window.get_active_document().get_short_name_for_display()
			self._save_file_chooser.set_current_name(filename)
			self._save_fa_id = self._save_file_chooser.connect(
				"file-activated",
				self.on_save_project,
				self.CHOOSER_SAVE
			)
			self._save_resp_id = self._save_file_chooser.connect( "response", self.on_save_project )
			self._save_file_chooser.show()

		else:
			return False

		return True


	def _has_gedit_project_extension( self, filename ):
		RANDOM_MARKER = "/45n687q2qVcsAHsfDord8326bfaW8e7c"
		filename = filename + RANDOM_MARKER
		if filename.find( ".gedit-project" + RANDOM_MARKER ) != -1: 
			return True
		else:
			return False


	def _show_alert( self, text=None, with_log=False, my_flags=Gtk.DialogFlags.MODAL ):
		alert_box_text = text + "\n"
		if with_log and self._message:
			self._message.sort()
			while self._message:
				alert_box_text = alert_box_text + self._message.pop() + "\n"
		alert_box = Gtk.MessageDialog(
			parent = self._window,
			flags = my_flags,
			type = Gtk.MessageType.INFO,
			buttons = Gtk.ButtonsType.OK,
			message_format = alert_box_text
		)
		alert_box.connect( "response", self.on_alert_response )
		alert_box.show()

	def on_alert_response( self, widget, data=None ): widget.hide()

	def on_open_files( self, widget, data=None ):
		"Activated when the user selects a file to open"
		if data == self.CHOOSER_OPEN:
			file_list = list()
			for file_uri in self._open_file_chooser.get_uris():
				file_list.append( file_uri )
			self._open_files( file_list )
			self._save_project( self._project.filename )
			if self._message: self._show_alert( "Files opened.\n", self.WITH_LOG )
		self._open_file_chooser.hide()

	def on_history_action( self, filename=None ):
		"Opens a recently used project file"
		if os.path.exists( filename ):
			self._open_project( filename )
			self._save_project( self._project.filename )
			if self._message: self._show_alert( "Project opened: " + os.path.basename( filename ), self.WITH_LOG )
		else:
			self._show_alert(	"Project not opened: "+ os.path.basename( filename ) + "\n\nProject file not found: \n" + filename )
		self._add_to_history( filename )

	def on_open_last_project_action( self ):
		if self._project.active == True:
			self.update_ui()
			return
		for filename in self._history:
			if os.path.exists( filename ):
				self._open_project( filename )
				self._save_project( self._project.filename )
				if self._message: self._show_alert( "Project opened: " + os.path.basename( self._project.filename ), self.WITH_LOG )
			else:
				self._show_alert(	"Project not opened: "+ os.path.basename( filename ) + "\n\nProject file not found: \n" + filename )
			self._add_to_history( filename )
			return
		self._show_alert("Project history list is empty")

	def on_open_file_as_project_action( self ):
		doc = self._window.get_active_document()
		if (doc and doc.get_uri_for_display() != None):
			filename = doc.get_uri_for_display()
			# print( "Opening file as project: " + filename )
			if self._project.active: 
				self._show_alert("Could not open project: " + filename + "\nReason: A project is already open")
				return
			if not self._has_gedit_project_extension( filename ):
				self._show_alert("Cannot open project.\nReason: Current file is not a '.gedit-project' file")
				return
			if os.path.exists( filename ):
				if doc in self._window.get_unsaved_documents():
					self._show_alert( "Cannot open current file as project.\nReason: Project file is modified but NOT SAVED." )
					return
				self._window.close_tab( Gedit.Tab.get_from_document( doc ))
				self._open_project( filename )
				self._save_project( filename )
				self._add_to_history( filename )
				if self._message: self._show_alert( "Project opened: " + os.path.basename( self._project.filename ), self.WITH_LOG )
			else: 
				self._show_alert(	"Project not opened: "+ os.path.basename( filename ) + "\n\nProject file not found: \n" + filename )

	def on_open_project( self, widget, data=None ):
		"Activated when the user opens a project from the chooser"
		if data == self.CHOOSER_OPEN:
			if self._open_file_chooser.get_filename():
				self._open_project( self._open_file_chooser.get_filename() )
				self._save_project( self._project.filename )
				self._add_to_history( self._project.filename )
				if self._message: self._show_alert( "Project opened: " + os.path.basename( self._project.filename ), self.WITH_LOG )
		self._open_file_chooser.hide()

	def on_save_project( self, widget, data=None ):
		"Activated when the user saves a project with the chooser"
		if data == self.CHOOSER_SAVE:
			if self._save_file_chooser.get_filename():
				filename = self._save_file_chooser.get_filename()
				if not self._has_gedit_project_extension( filename ):
					filename = filename + ".gedit-project"
				if os.path.exists( filename ):
					self._show_alert("Project file already EXISTS; it has not been replaced: " + filename )
				else:
					self._save_project( filename )
					self._add_to_history( filename )
					self._project.active = True
					self.update_ui()
					self._show_alert( "New project opened: " + os.path.basename( self._project.filename ) )
		self._save_file_chooser.hide()

	def _open_files( self, file_list ):
		for file_uri in file_list:
			# I did not like the os.path.exists check because it works only for local files; uris never return null and I prefer some empty files show up rather than restricting the projects to have local files; I wonder if there is a simple way to check for existence of the uri resource;
			file_is_not_open = True
			for item in self._window.get_documents():
				if item.get_uri_for_display()==file_uri.replace("file://",""):	# TODO: make this more abstract and independent of symlinks
					self._documents.append( item )
					file_is_not_open = False
					break
			if file_is_not_open:
				tab = self._window.create_tab_from_location (
					Gio.file_new_for_uri( file_uri ), # ridiculously obscure to understand how to transform to python for the gfile stuff; copied it from snap open plugin; the multiple versions of gtk make it impossible to navigate online to the version that is relevant, the fact that it is in Gio, etc. :@
					None,0,0,False,True
				)
				self._documents.append(tab.get_document())
			#else:
			#	self._message.append( " - The following file is ALREADY OPEN in gedit; it has not been loaded from disk: " + file_uri )
			self._project.add_file( file_uri )

	def _close_project( self ):
		# print( "Closing project ... " + self._project.filename )
		for item in self._window.get_documents():
			if item.get_uri_for_display() == None and not (item in self._window.get_unsaved_documents()):
				self._window.close_tab( Gedit.Tab.get_from_document( item ) )

		there_are_unsaved_files = False
		for item in self._window.get_documents():
			if item in self._documents:
				self._documents.remove(item)
				if not (item in self._window.get_unsaved_documents()):
					self._window.close_tab( Gedit.Tab.get_from_document( item ) )
				else:
					self._message.append(" - The following file is NOT SAVED; it has not been closed: " + item.get_uri_for_display())
		self._project.clear()
		self.update_ui()

	def _open_project( self, filename ):
		"Process the project file and open all the child files"
		for item in self._window.get_documents():
			if item.get_uri_for_display() == None and not (item in self._window.get_unsaved_documents()):
				self._window.close_tab( Gedit.Tab.get_from_document( item ) )

		self._project.filename = filename
		file_list = list()
		
		xml = minidom.parse( filename )
		for file_uri in xml.getElementsByTagName( 'file' ):
			file_list.append( file_uri.childNodes[0].data )
		self._open_files( file_list )
		self._project.active = True
		# print( "Opening project ... " + filename )

	def _save_project( self, filename ):
		"Output the project XML to a file"
		self._project.filename = filename
		self._saving_project = True
		
		# TODO: Compile an XML document out of self._project and save it
		out_xml = minidom.Document()
		out_xml.version = 1.0

		gedit_project_element = minidom.Element( 'gedit-project' )

		for file_uri in self._project.get_files():
			file_element = minidom.Element( 'file' )
			text_node = minidom.Text()
			text_node.data = file_uri
			file_element.childNodes.append( text_node )
			gedit_project_element.childNodes.append( file_element )

		out_xml.childNodes.append( gedit_project_element )

		outfile = open( self._project.filename, "w" )
		outfile.writelines( out_xml.toprettyxml() )
		outfile.close()

		# print( "Saving project ... " + self._project.filename )
		self._saving_project = False

class MenuProjectPlugin( GObject.Object, Gedit.WindowActivatable ):

	__gtype_name__ = "MenuProjectPlugin"
	window = GObject.property( type=Gedit.Window )
	instance = None

	def __init__( self ):
		GObject.Object.__init__( self )

	def do_activate( self ):
		self.instance=MenuProjectPluginInstance( self, self.window )

	def do_deactivate( self ):
		self.instance.deactivate()

	def update_state( self ):
		self.instance.update_ui()

