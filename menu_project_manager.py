# -*- coding: utf8 -*-
#	Menu Project Manager plugin
#
#	spetial thanks to Micah:
#	http://www.micahcarrick.com/writing-plugins-for-gedit-3-in-python.html
#
#	Copyright (C) 2013 Francisco Franchetti <nixahn@gmail.com>
#	Copyright (C) 2006 Alin Avasilcutei (Gyll) <avasilcuteia@gmail.com>
#
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330,
#	Boston, MA 02111-1307, USA.

# bugs/todo:
#	1_ gtk-critical when closing the py file for the plugin; it seems unrelated to this plugin, it happens when closing it normaly too; should try disabling other plugins (binary search)
#	2_ this bug is hard to reproduce, seems gone: (gedit:30664): GLib-GObject-WARNING **: /build/buildd/glib2.0-2.38.1/./gobject/gsignal.c:2593: instance '0x912d218' has no handler with id '6760'
#	3_ probably better to implement the history with xml too instead of with a simple file handler (open())
#	4_ should migrate to Gio.SimpleAction instead of the deprecated GtkAction
#	5_ there are issues with the sftp locations; the addision of files through the "choose_dialog" has a different way of storing the path than when one uses the "add current file menu item" (which depends on get_uri_for_display); in general there is a need to compare files more abstractly (instead of just the string that represents them); we should aim at allowing for any uri (including web url ones) in the project list and we should write a somewhat thorough function that checks if two strings are ultimately pointing at the same uri, indepently of links, notation, etc. The main problem now is that the powerful functions os.path to check existence and compare the strings are restricted to local paths; the gfile opener used depends on uri, so we have to manually port the uris to "eye friendly" paths generated by _get_uri_for_display to make them compatible. the chooser dialog tends to generate valid uris directly, although they don't coincide with the ones generated by get_uri_for_display when we are dealing with a non-local uri; something similar to this would help with the normalization (not the same as checking for the inode as os.path.samefile does though! ); it also misses the link resolution
# def fix_URL(urlstring):
#    parts = list(urlparse.urlparse(urlstring))
#    parts[2] = os.path.normpath(parts[2].replace('/', os.sep)).replace(os.sep, '/')
#    return urlparse.urlunparse(parts)
#	5_ open a new window when a new project is opened like the session manager did in gedit 2.x

# number ordering of history (possibly related to the lack of update)

from gi.repository import GObject, Gedit, Gtk ,Gio
from os.path import os
from sys import platform
from subprocess import call
from io import IOBase
# from urllib import request
from xml.dom import minidom

ui_str="""<ui>
<menubar name="MenuBar">
	<menu name="ProjectMenu" action="MenuMPAction">
		<placeholder name="ProjectOps_1">
			<menuitem name="NewProject" action="NewMPAction"/>
		</placeholder>
		<placeholder name="ProjectOps_2">
			<menuitem name="OpenProject" action="OpenMPAction"/>
			<menuitem name="OpenLastProjectMenu" action="OpenLastMPAction"/>
			<menuitem name="CloseProject" action="CloseMPAction"/>
			<separator />
			<menuitem name="OpenFileAsProject" action="OpenFileAsMPAction"/>
			<separator />
			<menuitem name="ViewProjectFiles" action="ViewProjectFilesMPAction"/>
			<menuitem name="ReopenAllFiles" action="ReopenAllFilesMPAction"/>
			<separator />
		</placeholder>
		<placeholder name="ProjectOps_3">
			<menuitem name="AddProjectFile" action="AddProjectFileMPAction"/>
			<menuitem name="AddCurrentFile" action="AddCurrentFileMPAction"/>
			<menuitem name="DelProjectFile" action="DelProjectFileMPAction"/>
			<separator />
		</placeholder>
		<placeholder name="ProjectOps_4">
			<menuitem name="OpenCurrentFileFolder" action="OpenCurrentFileFolderMPAction"/>
			<menuitem name="OpenProjectFolder" action="OpenProjectFolderMPAction"/>
			<separator />
		</placeholder>
		<placeholder name="ProjectOps_5">
		</placeholder>
	</menu>
</menubar>
<toolbar name="ToolBar">
	<separator />
	<toolitem name="OpenLastProjectButton" action="OpenLastButtonMPAction"/>
</toolbar> 
</ui>
"""
class ProjectData:

	def __init__( self ):
		self.filename = ""
		self._files = list()
		self.active = False

	def add_file( self, file_uri ):
		if file_uri in self._files:	#redundant
			return False
		print( "Adding file to project ... " + file_uri )
		self._files.append( file_uri )
		return True

	def del_file( self, file_uri ):
		if file_uri in self._files:	#redundant
			print( "Removing file from project ... " + file_uri )
			self._files.remove( file_uri )
			return True
		return False

	def get_files( self ):
		return self._files

	def clear( self ):
		self.name = ""
		self.filename = ""
		self._files = list()
		self.active = False

class MenuProjectPluginInstance:
	CHOOSER_OPEN = 10
	CHOOSER_SAVE = 11
	CHOOSER_CANCEL = 12
	CHOOSER_NEW = 13
	CHOOSER_OK = 14
	OPEN_PROJECT = 20
	SAVE_PROJECT = 21
	NEW_PROJECT = 22
	ADD_FILES = 23
	SAVE_FILE = 24
	SAVE_AND_CLOSE_FILE = 25
	WITH_LOG = True
	MAX_HISTORY_FILE_NO = 15
	STATE_PROJECT_NO_FILES_NO	= 0
	STATE_PROJECT_YES_FILES_NO	= 1
	STATE_PROJECT_NO_FILES_YES	= 2
	STATE_PROJECT_YES_FILES_YES = 3
	
	CAN_ADD_FILE = 1
	CAN_REM_FILE = 2
	
	GEDIT_PLUGIN_FOLDER = "/.local/share/gedit/plugins"

	# Default 3 methods
	def __init__( self, plugin, window ):
		self._window = window
		self._documents = list()
		self._plugin = plugin
		self._project = ProjectData()
		self._history_file = os.path.expanduser( '~' ) + self.GEDIT_PLUGIN_FOLDER+"/menu_project_manager_history"
		self._history = list()
		self._action_group_main = Gtk.ActionGroup( "MenuProjectPluginActions" )
		self._action_group_history = Gtk.ActionGroup( "MenuProjectPluginHistoryActions" )
		self._state = self.STATE_PROJECT_NO_FILES_NO
		self._add_remove_state = None
		self._message = list()
		self._updating = False
		
		self._init_history()
		self._create_choosers()
		self._insert_menu()
		self.update_ui()

	def deactivate( self ):
		self._remove_menu()
		self._action_group_main = None
		self._action_group_history= None
		self._project = None
		self._plugin = None
		self._window = None

		self._open_file_chooser = None
		self._save_file_chooser = None

	def update_ui( self ):
		self._set_history_ui()
		self._update_menu_ui()

	# History methods
	def _init_history( self ):
		if os.path.exists( self._history_file ):
			hist_fp = open( self._history_file, "r" )
			try:
				for line in hist_fp:
					filename=line.rstrip("\n")
					if os.path.exists( filename):
						self._history.insert( len( self._history ) , filename)
			finally:
				hist_fp.close()
		else:
			hist_fp = open( self._history_file, "w" )
			hist_fp.close()

	def _refresh_history( self, filename ):
		for item in self._history:
			#if item == filename:
			if os.path.samefile(item,filename): #avoids symlink duplicates
				self._history.remove( item )
		if os.path.exists(filename):
			if len( self._history ) == self.MAX_HISTORY_FILE_NO:
				self._history.pop( len( self._history )-1 )
			self._history.insert( 0, filename )

	def _save_history( self ):
		hist_fp = open( self._history_file, "w" )
		for line in self._history:
			hist_fp.write( line + "\n" )
		hist_fp.close()

	def _set_history_ui( self ):
		if not self._updating:
			self._updating = True
			manager = self._window.get_ui_manager()
			# remove old history
			manager.remove_ui( self._ui_id_history )
			manager.remove_action_group(self._action_group_history)
			self._action_group_history = Gtk.ActionGroup( "MenuProjectPluginHistoryActions" )
			# insert new history
			if len(self._history) != 0:
				# for the order to work, ensure_update must be run every time an element is added to the ui; to avoid errors, the actions must be available prior to the addition of the ui elements; so we need 2 for loops; :@; not sure how an empty element could be present in self._history, check seems unnecesary
				for project in self._history:
					if project != "":
						self._insert_history_menu_item_action( project, self._history.index( project ) )
				manager.insert_action_group( self._action_group_history, 1 )
				for project in self._history:
					if project != "":
						self._insert_history_menu_item_ui( manager, project )
			self._updating = False

	def _insert_history_menu_item_action( self, filename, position ):
		name, ext = os.path.splitext( os.path.basename( filename ) )
		history_action = Gtk.Action(
			name = name + "MPAction",
			label = str( position + 1 ) + ". " + name,
			tooltip = name,
			stock_id = None
		)
		history_action.connect("activate", lambda a: self.on_history_action(filename) )
		history_action.set_sensitive( not self._project.active )
		history_action.set_visible(True)
		self._action_group_history.add_action( history_action )

	def _insert_history_menu_item_ui( self, manager, filename ):
		name, ext = os.path.splitext( os.path.basename( filename ) )
		manager.add_ui(
			merge_id = self._ui_id_history,
			path = "/MenuBar/ProjectMenu/ProjectOps_5",
			name = name,
			action = name + "MPAction",
			type = Gtk.UIManagerItemType.AUTO,
			top = False
		)
		manager.ensure_update()

	# Menu state methods
	def _update_menu_ui( self ):
		if not self._updating:
			self._updating = True
			manager = self._window.get_ui_manager()
			self._add_remove_state = None
			doc=self._window.get_active_document()
			if (doc and doc.get_uri_for_display() != None):
				if (self._project.active):
					self._state = self.STATE_PROJECT_YES_FILES_YES
					if (doc in self._documents):
						self._add_remove_state = self.CAN_REM_FILE
					else:
						self._add_remove_state = self.CAN_ADD_FILE
				else:
					self._state = self.STATE_PROJECT_NO_FILES_YES
			else:
				if (self._project.active):
					self._state = self.STATE_PROJECT_YES_FILES_NO
				else:
					self._state = self.STATE_PROJECT_NO_FILES_NO

			manager.get_action("/ToolBar/OpenLastProjectButton").set_sensitive( len(self._history) != 0 and not self._project.active)

			manager.get_action("/MenuBar/ProjectMenu/ProjectOps_1/NewProject").set_sensitive( not self._project.active )
			manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/OpenProject").set_sensitive( not self._project.active )

			manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/OpenFileAsProject").set_sensitive( not self._project.active )
			if (not self._project.active):
				if self._window.get_active_document() and self._window.get_active_document().get_uri_for_display():
					if self._has_gedit_project_extension(self._window.get_active_document().get_uri_for_display()):
						manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/OpenFileAsProject").set_sensitive( True )

			manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/OpenLastProjectMenu").set_sensitive( len(self._history) != 0 and not self._project.active)

			if (self._state == self.STATE_PROJECT_NO_FILES_NO):
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/CloseProject").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ViewProjectFiles").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ReopenAllFiles").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddProjectFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenProjectFolder").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenCurrentFileFolder").set_sensitive(False)
			elif (self._state == self.STATE_PROJECT_YES_FILES_NO):
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/CloseProject").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ViewProjectFiles").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ReopenAllFiles").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddProjectFile").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenProjectFolder").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenCurrentFileFolder").set_sensitive(False)
			elif (self._state == self.STATE_PROJECT_NO_FILES_YES):
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/CloseProject").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ViewProjectFiles").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ReopenAllFiles").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddProjectFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenProjectFolder").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenCurrentFileFolder").set_sensitive(True)
			elif (self._state == self.STATE_PROJECT_YES_FILES_YES):
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/CloseProject").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ViewProjectFiles").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_2/ReopenAllFiles").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddProjectFile").set_sensitive(True)
					if (self._add_remove_state == self.CAN_ADD_FILE):
						manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(True)
					else:
						manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/AddCurrentFile").set_sensitive(False)
					if (self._add_remove_state == self.CAN_REM_FILE):
						manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(True)
					else:
						manager.get_action("/MenuBar/ProjectMenu/ProjectOps_3/DelProjectFile").set_sensitive(False)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenProjectFolder").set_sensitive(True)
					manager.get_action("/MenuBar/ProjectMenu/ProjectOps_4/OpenCurrentFileFolder").set_sensitive(True)
			self._updating = False

	def _update_menu_ui_callback( self, window, tab ):
		self._update_menu_ui()

	# Chooser methods
	def _create_choosers( self ):
		# Creates open/save file choosers for opening and saving projects
		self.project_file_filter = Gtk.FileFilter()
		self.project_file_filter.add_pattern("*.gedit-project")
		self.all_files_filter = Gtk.FileFilter()
		self.all_files_filter.add_pattern("*")

		self._open_file_chooser = Gtk.FileChooserDialog(
			"Open Project File",
			self._window,
			Gtk.FileChooserAction.OPEN
		)
		self._open_file_chooser.set_select_multiple( False )
		self._open_file_chooser.add_buttons(
			Gtk.STOCK_OPEN, self.CHOOSER_OPEN,
			Gtk.STOCK_CANCEL, self.CHOOSER_CANCEL
		)
		self._save_file_chooser = Gtk.FileChooserDialog(
			"Save Project File",
			self._window,
			Gtk.FileChooserAction.SAVE
		)
		self._save_file_chooser.set_select_multiple( False )
		self._save_file_chooser.add_buttons(
			Gtk.STOCK_SAVE, self.CHOOSER_SAVE,
			Gtk.STOCK_CANCEL, self.CHOOSER_CANCEL
		)
		self._open_fa_id = -1
		self._open_resp_id = -1
		self._save_fa_id = -1
		self._save_resp_id = -1

	def _show_chooser( self, chooser_type ):
		# A unified interface to show both open/save file choosers
		if self._open_fa_id > -1: self._open_file_chooser.disconnect( self._open_fa_id )
		if self._open_resp_id > -1: self._open_file_chooser.disconnect( self._open_resp_id )
		if self._save_fa_id > -1: self._save_file_chooser.disconnect( self._save_fa_id )
		if self._save_resp_id > -1: self._save_file_chooser.disconnect( self._save_resp_id )

		if chooser_type == self.OPEN_PROJECT:
			self._open_file_chooser.set_title( "Open Project File" )
			self._open_file_chooser.set_filter(self.project_file_filter)
			self._open_file_chooser.set_select_multiple( False )
			self._open_fa_id = self._open_file_chooser.connect( "file-activated", 
			self.on_open_project,
			self.CHOOSER_OPEN )
			self._open_resp_id = self._open_file_chooser.connect( "response", self.on_open_project )
			self._open_file_chooser.show()

		elif chooser_type == self.ADD_FILES:
			self._open_file_chooser.set_title( "Add File to Project" )
			self._open_file_chooser.set_filter(self.all_files_filter)
			self._open_file_chooser.set_select_multiple( True )
			self._open_fa_id = self._open_file_chooser.connect( "file-activated",
			self.on_add_files,
			self.CHOOSER_OPEN )
			self._open_resp_id = self._open_file_chooser.connect( "response", self.on_add_files )
			self._open_file_chooser.show()

		elif chooser_type == self.NEW_PROJECT:
			self._save_file_chooser.set_title( "Save New Project File As ..." )
			self._save_file_chooser.set_filter(self.project_file_filter)
			filename="new_project"
			if self._window.get_active_document():
				filename=self._window.get_active_document().get_short_name_for_display()
			self._save_file_chooser.set_current_name(filename)
			self._save_fa_id = self._save_file_chooser.connect(
				"file-activated",
				self.on_new_project,
				self.CHOOSER_SAVE
			)
			self._save_resp_id = self._save_file_chooser.connect( "response", self.on_new_project )
			self._save_file_chooser.show()

		else:
			return False

		return True

	# Menu methods
	def _insert_menu( self ):
		# Create and add the Project menu to the menubar
		#TOOLBAR
		open_last_project_button_action = Gtk.Action(
			name="OpenLastButtonMPAction",
			label="Last Project",
			tooltip="Reopen the last project",
			stock_id=Gtk.STOCK_GO_BACK
		)
		open_last_project_button_action.connect( "activate", lambda a: self.on_open_last_project_action() )
		self._action_group_main.add_action( open_last_project_button_action )

		# PROJECT MENU
		project_menu_action = Gtk.Action(
			name="MenuMPAction",
			label="Project",
			tooltip="Project menu",
			stock_id=None
		)
		project_menu_action.connect( "activate", lambda a: self.update_ui() )
		self._window.connect( "active-tab-changed", self._update_menu_ui_callback )
		self._action_group_main.add_action( project_menu_action )

		## First Placeholder
		new_project_action = Gtk.Action(	name="NewMPAction",
											label="New Project...\t",
											tooltip="Create a new project",
											stock_id=Gtk.STOCK_NEW )
		new_project_action.connect( "activate", lambda a: self.on_new_project_action() )
		self._action_group_main.add_action( new_project_action )

		open_project_action = Gtk.Action(
			name="OpenMPAction",
			label="Open Project...\t",
			tooltip="Open a project file",
			stock_id=Gtk.STOCK_OPEN
		)
		open_project_action.connect( "activate", lambda a: self.on_open_project_action() )
		self._action_group_main.add_action( open_project_action )

		open_last_project_menu_action = Gtk.Action(
			name="OpenLastMPAction",
			label="Open Last Project",
			tooltip="Reopen the last project",
			stock_id=Gtk.STOCK_GO_BACK
		)
		open_last_project_menu_action.connect( "activate", lambda a: self.on_open_last_project_action() )
		self._action_group_main.add_action( open_last_project_menu_action )

		close_project_action = Gtk.Action(
			name="CloseMPAction",
			label="Close Project\t",
			tooltip="Closes the current project",
			stock_id=Gtk.STOCK_QUIT
		)
		close_project_action.connect( "activate", lambda a: self.on_close_project_action() )
		self._action_group_main.add_action( close_project_action )

		## Second Placeholder
		open_file_as_project_action = Gtk.Action(
			name="OpenFileAsMPAction",
			label="Open Current File as Project\t",
			tooltip="Open the project associated with the current '.gedit-project' file",
			stock_id=None
		)
		open_file_as_project_action.connect( "activate", lambda a: self.on_open_file_as_project_action() )
		self._action_group_main.add_action( open_file_as_project_action )

		## Third Placeholder
		view_project_files_action = Gtk.Action(
			name="ViewProjectFilesMPAction",
			label="View Project File List\t",
			tooltip="Displays a list with the files in the project.",
			stock_id=Gtk.STOCK_INFO
		)
		view_project_files_action.connect( "activate", lambda a: self.on_view_project_files_action() )
		self._action_group_main.add_action_with_accel( view_project_files_action, "<Ctrl>3" )
		open_all_files_action = Gtk.Action(
			name="ReopenAllFilesMPAction",
			label="Open All Files In Project\t",
			tooltip="Opens all the files contained in the current project",
			stock_id=Gtk.STOCK_REFRESH
		)
		open_all_files_action.connect( "activate", lambda a: self.on_open_all_files_action() )
		self._action_group_main.add_action_with_accel( open_all_files_action, "<Ctrl>2" )

		## Fourth Placeholder
		add_files_action = Gtk.Action(
			name="AddProjectFileMPAction",
			label="Add Files ...\t",
			tooltip="Adds an existing file to the opened project",
			stock_id=Gtk.STOCK_DND_MULTIPLE
		)
		add_files_action.connect( "activate", lambda a: self.on_add_files_action() )
		self._action_group_main.add_action( add_files_action )

		add_current_file_action = Gtk.Action(
			name="AddCurrentFileMPAction",
			label="Add Current File\t",
			tooltip="Adds the current file to the opened project",
			stock_id=Gtk.STOCK_DND
		)
		add_current_file_action.connect( "activate", lambda a: self.on_add_current_file_action() )
		self._action_group_main.add_action_with_accel( add_current_file_action, "<Ctrl>1" )
		del_current_file_action = Gtk.Action(
			name="DelProjectFileMPAction",
			label="Remove Current File\t",
			tooltip="Removes the active file from the project",
			stock_id=Gtk.STOCK_DELETE
		)
		del_current_file_action.connect( "activate", lambda a: self.on_del_current_file_action() )
		self._action_group_main.add_action_with_accel( del_current_file_action, "<Ctrl>0" )
		
		## Fifth Placeholder
		open_project_folder_action = Gtk.Action(
			name="OpenProjectFolderMPAction",
			label="Open Project File Folder...\t",
			tooltip="Open the folder containing the project file.",
			stock_id=None
		)
		open_project_folder_action.connect( "activate", lambda a: self.on_open_project_folder_action() )
		self._action_group_main.add_action( open_project_folder_action )

		open_file_folder_action = Gtk.Action(
			name="OpenCurrentFileFolderMPAction",
			label="Open Current File Folder...\t",
			tooltip="Open the current project's folder.",
			stock_id=None
		)
		open_file_folder_action.connect( "activate", lambda a: self.on_open_files_folder_action() )
		self._action_group_main.add_action( open_file_folder_action )

		manager = self._window.get_ui_manager()
		manager.insert_action_group( self._action_group_main, 0 )
		manager.insert_action_group( self._action_group_history, 1 )
		
		self._ui_id_history = manager.new_merge_id()
		self._ui_id_main = manager.add_ui_from_string( ui_str )
		manager.ensure_update()

	def _remove_menu( self ):
		# removes the project menu items from the menu
		manager = self._window.get_ui_manager()
		manager.remove_ui( self._ui_id_history )
		manager.remove_ui( self._ui_id_main )
		manager.remove_action_group( self._action_group_main )
		manager.remove_action_group( self._action_group_history )
		manager.ensure_update()

	# Action Methods (code order different from menu)
	## Chooser Actions
	def on_new_project_action( self ):
		# Displays the new project dialog box
		self._show_chooser( self.NEW_PROJECT )

	def on_open_project_action( self ):
		# Activated when the 'open project' menu item is selected
		self._show_chooser( self.OPEN_PROJECT )

	def on_add_files_action( self ):
		# Adds an existing file to the active project
		self._show_chooser( self.ADD_FILES )
	
	## Actions that open a project
	def on_open_last_project_action( self ):
		# Opens the last project that was active
		for filename in self._history:
			self._open_project_ui( filename )
			return
		if self._message: self._show_alert(
			"Project history list is empty"
		)

	def on_open_file_as_project_action( self ):
		# Opens currently opened file as a project
		doc = self._window.get_active_document()
		if (doc and doc.get_uri_for_display() != None):
			filename = doc.get_uri_for_display()
			if not self._has_gedit_project_extension( filename ):
				if self._message: self._show_alert(
					"Cannot open project.\nReason: Current file is not a '.gedit-project' file"
				)
				return
			if doc in self._window.get_unsaved_documents():
				if self._message: self._show_alert(
					"Cannot open current file as project.\nReason: Project file is modified but NOT SAVED."
				)
				return
			if self._open_project_ui( filename ):
				self._window.close_tab( Gedit.Tab.get_from_document( doc ))

	def on_history_action( self, filename=None ):
		# Opens a recently used project file
		self._open_project_ui( filename )

	def _open_project_ui( self, filename):
		# Avoids duplication of code; not implemented in _open_project to separate the gui messages and existence checks from actual file/memory operations in _open_proejct
		if self._project.active: 
			if self._message: self._show_alert(
				"Could not open project: " +
				filename +
				"\nReason: A project is already open"
			)
			return 0
		if os.path.exists( filename ):
			self._open_project( filename )
			if self._message: self._show_alert(
				"Project opened: " +
				os.path.basename( filename )
			, self.WITH_LOG )
			return 1
		else:
			if self._message: self._show_alert(
				"Project not opened: " +
				os.path.basename( filename ) +
				"\n\nProject file not found: \n" +
				filename
			)
			return 0

	def on_open_all_files_action( self ):
		# Open all files in the project
		if self._project.active:
			filename = self._project.filename
			self._open_project( filename )
			if self._message: self._show_alert( "Project reopened: '" + os.path.basename( filename ) + "'", self.WITH_LOG )
	
	def on_close_project_action( self ):
		# Close the active project
		if self._project.active:
			if self._message: self._show_alert( "Project closed: " + self._project.filename, self.WITH_LOG )
			self._close_project()

	def on_view_project_files_action( self ):
		# Shows a list of the current files in the project
		# an option here is to implement this based on the elements in memory instead of parsing the xml file again
		file_list = list()
		filename = self._project.filename
		xml = minidom.parse( filename )
		for file_uri in xml.getElementsByTagName( 'file' ):
			file_list.append( file_uri.childNodes[0].data )
		message = "Current project:\n" + filename + "\n\nFiles in the project:"
		while file_list:
			message = message + "\n - " + file_list.pop()
		self._show_alert( message , False, Gtk.DialogFlags.DESTROY_WITH_PARENT )

	def on_add_current_file_action( self ):
		# Adds the active file to the active project.
		if self._add_current_file():
			if self._message: self._show_alert(
				"The current file has been ADDED to the project"
			)
		else:
			if self._message: self._show_alert(
				"The current file is ALREADY IN the project"
			)
	
	def on_del_current_file_action( self ):
		# Removes the active file from the active project.
		if self._del_current_file():
			if self._message: self._show_alert(
				"The current file has been REMOVED from the project"
			)
		else:
			if self._message: self._show_alert(
				"The current file does not belong to the project"
			)

	def on_open_project_folder_action( self ):
		# Open the current project folder
		if os.path.dirname(self._project.filename):
			f=os.path.dirname(self._project.filename)
			if platform == 'linux':
				call(["xdg-open",f])
			else:
				os.startfile(f)
		else:
			if self._message: self._show_alert(
				"Can not open the project folder.\nReason: Path not found."
			)

	def on_open_files_folder_action( self ):
		# Open the current file folder
		if (self._window.get_active_document()):
			if(self._window.get_active_document().get_uri_for_display()):
				current_file = self._window.get_active_document().get_uri_for_display()
				if os.path.dirname(current_file):
					f=os.path.dirname(current_file)
					if platform == 'linux': # http://stackoverflow.com/questions/1679798/how-to-open-a-file-with-the-standard-application
						call(["xdg-open",f])
					else:
						os.startfile(f)
				else:
					if self._message: self._show_alert(
						"Can not open the project folder.\nReason: Path not found."
					)
		else:
			if self._message: self._show_alert(
				"There is no open file or the current file is untitled."
			)

	def on_alert_response( self, widget, data=None ): widget.hide()

	# Event methods
	def on_new_project( self, widget, data=None ):
		# Activated when the user creates a new project with the chooser
		if data == self.CHOOSER_SAVE:
			if self._save_file_chooser.get_filename():
				filename = self._save_file_chooser.get_filename()
				if not self._has_gedit_project_extension( filename ):
					filename = filename + ".gedit-project"
				if os.path.exists( filename ):
					if self._message: self._show_alert("Project file already EXISTS; it has not been replaced: " + filename )
				else:
					self._new_project( filename )
					if self._message: self._show_alert( "New project created and opened: " + os.path.basename( filename ) )
			self._save_file_chooser.hide()

	def on_open_project( self, widget, data=None ):
		# Activated when the user opens a project from the chooser
		if data == self.CHOOSER_OPEN:
			filename=self._open_file_chooser.get_filename()
			if filename:
				self._open_project( filename )
				if self._message: self._show_alert( "Project opened: " + os.path.basename( filename ), self.WITH_LOG )
			self._open_file_chooser.hide()

	def on_add_files( self, widget, data=None ):
		# Activated when the user selects a set of files to add from the chooser
		if data == self.CHOOSER_OPEN:
			file_list = list()
			for file_uri in self._open_file_chooser.get_uris():
				file_list.append( file_uri )
			self._add_files( file_list )
			if self._message: self._show_alert( "Files added.\n", self.WITH_LOG )
			self._open_file_chooser.hide()

	# Aux methods
	def _has_gedit_project_extension( self, filename ):
		RANDOM_MARKER = "/45n687q2qVcsAHsfDord8326bfaW8e7c"
		filename = filename + RANDOM_MARKER
		if filename.find( ".gedit-project" + RANDOM_MARKER ) != -1: 
			return True
		else:
			return False

	def _show_alert( self, text=None, with_log=False, my_flags=Gtk.DialogFlags.MODAL ):
		alert_box_text = text + "\n"
		if with_log and self._message:
			self._message.sort()
			while self._message:
				alert_box_text = alert_box_text + self._message.pop() + "\n"
		alert_box = Gtk.MessageDialog(
			parent = self._window,
			flags = my_flags,
			type = Gtk.MessageType.INFO,
			buttons = Gtk.ButtonsType.OK,
			message_format = alert_box_text
		)
		alert_box.connect( "response", self.on_alert_response )
		alert_box.show()

	def _uri_from_display( self, display ):
		# Modifiy uri_for display here to make the value a true uri with file:// preceeding and %20 where spaces are; that prepending is necessary tomake the value readable later for the gfile new_for_uri method; using this instead of new_for_path allows to have files in the project with more flexible locations (sftp) and such
		# There should be some library that I couldn't find doing this kind of path->uri conversion;
		uri=display.replace(" ","%20")
		if os.path.isabs(display):
			uri = "file://" + uri
		return uri

	def _display_from_uri ( self, uri ):
		#Inverse of _uri_from_display
		display=uri.replace("%20"," ")
		return display.replace("file://","")

	# Core methods
	def _new_project( self, filename ):
		# Create the new project
		self._save_project( filename )
		self._set_project( filename )

	def _open_project( self, filename ):
		# Process the project file and open all the child files
		for item in self._window.get_documents():
			if item.is_untouched() and item.is_untitled():
#			if item.get_uri_for_display() == None and not (item in self._window.get_unsaved_documents()):
				self._window.close_tab( Gedit.Tab.get_from_document( item ) )

		file_list = list()
		
		xml = minidom.parse( filename )
		for file_uri in xml.getElementsByTagName( 'file' ):
			file_list.append( file_uri.childNodes[0].data )
		self._open_files( file_list )
		self._save_project( filename )
		self._set_project ( filename )

	def _close_project( self ):
		# Close active project
		for item in self._window.get_documents():
			if item in self._documents:
				# self._documents.remove(item)	# this is not great cause closed documents want be removed from the list! not a big issue though since having garbage in the list does not affect us (not saving projects based on this list)
				if not item in self._window.get_unsaved_documents():
					self._window.close_tab( Gedit.Tab.get_from_document( item ) )
		self._documents = list()	# avoiding clear method because is too new
		self._project.clear()
		self.update_ui()	# perhaps just self._update_history_ui() is needed

	def _add_files( self, file_list ):
		# Opens and adds to the active project the list of files
		self._open_files( file_list )
		self._save_project( self._project.filename )

	def _add_current_file( self ):
		# Adds the current file to the active project without openning it
		if self._window.get_active_document():
			doc = self._window.get_active_document()
			if doc in self._documents:
				return 0

			if not doc.get_location():
				return 0

			self._project.add_file( self._uri_from_display ( doc.get_uri_for_display() ) )	# repetition is checked internally in add_file
			self._save_project( self._project.filename )
			self._documents.append(doc)
			self._update_menu_ui()
			return 1
		else:
			return 0

	def _del_current_file( self ):
		doc = self._window.get_active_document()
		if doc:			
			if doc in self._documents:
				self._project.del_file( self._uri_from_display ( doc.get_uri_for_display() ) )
				self._save_project( self._project.filename )
				#self._window.close_tab( Gedit.Tab.get_from_document( doc ) )
				self._documents.remove( doc )
				self._update_menu_ui()
				return 1
			else:
				return 0
		else:
			return 0
	
	def _open_files( self, file_list ):
		for file_uri in file_list:
			# I wonder if there is a simple way to check for existence of the uri resource here;
			file_is_not_open = True
			for item in self._window.get_documents():
				if item.get_uri_for_display()==self._display_from_uri(file_uri):	# TODO: make this more abstract and independent of symlinks
					file_is_not_open = False
					doc = item
					break
			if file_is_not_open:
				tab = self._window.create_tab_from_location (
					Gio.file_new_for_uri( file_uri ), # ridiculously obscure to understand how to transform to python for the gfile stuff; copied it from snap open plugin; the multiple versions of gtk make it impossible to navigate online to the version that is relevant, the fact that it is in Gio, etc. :@
					None,0,0,False,True
				)
				doc = tab.get_document()
			#else:
			#	self._message.append( " - The following file is ALREADY OPEN in gedit; it has not been loaded from disk: " + file_uri )
			if not doc in self._documents:
				self._project.add_file( file_uri )
				self._documents.append(doc)

	def _set_project( self, filename ):
		# The following three methods do not need functions since they are called only once in the entire code and here;
		self._project.filename = filename
		self._project.active = True
		self._refresh_history( filename )
		self._save_history()	# needs to be called after refresh, should probably be integrated inside it;
		self.update_ui()		# perhaps just self._update_history_ui() is needed

	def _save_project( self, filename ):
		# Output the project XML to a file
		# TODO: Compile an XML document out of self._project and save it
		out_xml = minidom.Document()
		out_xml.version = 1.0

		gedit_project_element = minidom.Element( 'gedit-project' )

		for file_uri in self._project.get_files():
			file_element = minidom.Element( 'file' )
			text_node = minidom.Text()
			text_node.data = file_uri
			file_element.childNodes.append( text_node )
			gedit_project_element.childNodes.append( file_element )

		out_xml.childNodes.append( gedit_project_element )

		outfile = open( filename, "w" )
		outfile.writelines( out_xml.toprettyxml() )
		outfile.close()

class MenuProjectPlugin( GObject.Object, Gedit.WindowActivatable ):

	__gtype_name__ = "MenuProjectPlugin"
	window = GObject.property( type=Gedit.Window )
	instance = None

	def __init__( self ):
		GObject.Object.__init__( self )

	def do_activate( self ):
		self.instance=MenuProjectPluginInstance( self, self.window )

	def do_deactivate( self ):
		self.instance.deactivate()

	def update_state( self ):
		self.instance.update_ui()

